# Node.js, Express, PostgreSQL API template

## What is this?

NEAP starter template demonstrates a Node.js API connected to a postgreSQL database in a small, simple package.

## Requirements

- Node.js and npm
- [Postgres.app](http://postgresapp.com/)
- Postgres GUI tool [Postico](https://eggerapps.at/postico/)

## Getting Started

1. Fork, clone, and enter your directory.

2. `npm install` to get all required node packages

3. create your database using Postico or psql on the command line, then update your `config/.knexfile` with your new DB name

4. `nodemon server.js` to run your server, DB migration should run automatically if you have .knexfile configured correctly with your DB name, as well as Postgres.app running.

## Database Configuration

First, we need to add a table name to our migration file. Now would be a great time to add a table name, as well as some columns to our database.

Open our config/knexfile.js file and update our connection string to include your PG database:

```javascript
// Update with your config settings.
module.exports = {
    // development configuration for local PG
    development: {
        client: 'pg',
        connection: 'postgres://localhost/YOUR_DATABASE_NAME_HERE',
        migrations: {
            'directory': __dirname + "/migrations",
            tableName: "users"
        }
    }
}
```

Once we have configured our knexfile.js, lets take a look at our migration directory. We have a file with `firstMigration.js` at the end. This is the magic which generates our table with columns of various types and titles. This table, along with our columns, will be generated automatically by our `database_config.js` file later on!

```javascript
exports.up = function(knex, Promise) {
  return Promise.all([
    knex.schema.createTableIfNotExists('YOUR_TABLE_NAME_HERE', function(table){
      table.increments('id').primary()
      table.text("post_contents")
      table.text("created_at")
      table.text("updated_at")
    })
  ])
}
exports.down = function(knex, Promise) {
  knex.schema.dropTable('YOUR_TABLE_NAME_HERE')
}
```

### Before we continue, lets verify our table structure was generated by our migration. Open up Postico and take a look.

1. open Postico, navigate to your created database
2. run `nodemon server.js`
3. Hope for no errors. If you error out here, make sure you have completed the following:

  - run Postgres.app and started your server
  - correctly set up a connection to your local connection with Postico
  - Created your database
  - added your data base to the connection string to your knexfile `'postgres://localhost/YOUR_DATABASE_NAME_HERE'`
  - added a table name which does not exist to your migration file.

If all has gone well, you should be looking at this:
![dbtable](http://alexmurphy.me/img/neap_template/dbtable.png)

### Knex, Bookshelf.js, ModelBase oh my!

Lets take a look at our DB configuration file, database_config.js.

#### A note on migrations

`knex.migrate.latest([config])` is the magic line which executes our migration on server load. This creates our table and columns we will be appending to later. without this line, we would have to manually run our migraiton using the command `knex migrate:latest` using the knex CLI.

```javascript
    var config = require('./knexfile.js')
    var env = 'development'
    // knex config
    var knex = require('knex')(config[env])
    knex.migrate.latest([config])
    // bookshelf config
    bookshelf = require('bookshelf')(knex)
    bookshelf.plugin('registry')
    module.exports = bookshelf
    // bookshelf-modelbase
    var ModelBase = require('bookshelf-modelbase')(bookshelf)
```

What the hell is all this stuff? short answer, the tools we are using serve as abstractions on top of SQL to get our querying done and use the JS object model we all know so well. Knex is the SQL connector for our javascript, allowing us to change db tables and query in the classic SQL fashion. Bookshelf.js is for the object notation abstraction. Finally we use bookshelf-modelbase to access a bunch of pre build models for CRUD operations.

JS object notation create query for example:

```javascript
  userTable.create({ name:'Stimpy Dangerfield', pw:'foobarbaz', occupation: 'Private Eye' })
```

As apposed to classic SQL, who wants to do this any more?

```sql
  INSERT INTO userTable (name, pw, occupation)
  VALUES('Stimpy Dangerfield', 'foobarbaz', 'Private Eye');
```

### Manual Knex Migration (how and why)

If we want to alter our table structure, or add new tables, we will be creating a new migration.

#### A note on manual migration using the knex CLI. First, install the knex CLI globally if you don't have it:

`npm install knex --global` Next, navigate to your config directory and run the following command to create a new migration: `knex migrate:create migrationName` execute our migration and create our table with columns: `knex migrate:latest`

![migration](http://alexmurphy.me/img/neap_template/migration.png)

### API Routing using Express

Next, lets look at our `app/routes.js` file. This file defines our express routes for our API. From there, you can declare your database table and use bookshelf.js in conjunction with bookshelf-modelbase to append data into your table. See the following example, In this case I am appending data into my DB based on a POST route:

```javascript
  var yourTable = ModelBase.extend({
    tableName: 'YOUR_TABLE_NAME_HERE'
  })

  // api route
  router.route('/logToDatabase').post(function(req, res) {
    yourTable.create({ 'post_body' : req.body })
      .catch((error) => {
        console.log(error)
        res.send("error")
      })
      .then((collection) => {
        console.log( 'record added:' + collection )
        res.send('Record added to DB')
      })
  })
```

### Next, use PostMan to test our route.

![postman](http://alexmurphy.me/img/neap_template/postman.png)

### And our final result, a record in our DB!!!!

![dbrecord](http://alexmurphy.me/img/neap_template/dbrecord.png)
